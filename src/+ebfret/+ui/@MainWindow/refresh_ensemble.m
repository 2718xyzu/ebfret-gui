function refresh_ensemble(self, index)
    status = get(self, 'status');
    handles = get(self, 'handles');
    plots = get(self, 'plots');
    series = get(self, 'series');
    analysis = get(self, 'analysis');
    if length(analysis) > 0
        if nargin < 2
            a = status.cur_analysis;
        else 
            a = index;
            status.cur_analysis = index;
            set_value(handles.ensembleControl, index);
            set(self, 'status', status);
        end
        % set plot colors
        colors = struct2cell(ebfret.plot.colors());
        plots.colors.state = {colors{1:analysis(a).dim.states}};
        
        % create posterior plots
        x = cat(1, series.values);
        g = cat(1, analysis(a).expect.z);
        w_m = cat(2, analysis(a).posterior.mu);
        w_beta = cat(2, analysis(a).posterior.beta);
        w_a = 0.5 * cat(2, analysis(a).posterior.nu);
        w_b = 0.5 ./ cat(2, analysis(a).posterior.W);
        w_alpha = cat(3, analysis(a).posterior.A);
        plots.posterior.obs = ...
            ebfret.plot.state_obs(x, 'weights', g, ...
                                  'linestyle', '-', ...
                                  'color', plots.colors.state);
        plots.posterior.mean = ...
            ebfret.plot.state_mean(w_m, w_beta, w_a, w_b, ...
                                   'linestyle', '-', ...
                                   'color', plots.colors.state);
        plots.posterior.noise = ...
            ebfret.plot.state_stdev(w_a, w_b, ...
                                    'linestyle', '-', ...
                                    'color', plots.colors.state);
        E_tau = -1 ./ log(diag(ebfret.stat.normalize(mean(w_alpha,3), 2)));
        plots.posterior.dwell = ...
            ebfret.plot.state_dwell(w_alpha, ...
                                  'xdata', arrayfun(@(tau) exp(linspace(log(0.01 * tau), log(100 * tau), 101))', ...
                                                E_tau(:)', 'UniformOutput', false), ...
                                  'linestyle', '-', ...
                                  'color', plots.colors.state);
        % set axis limits based on posterior plots
        sph = get(handles.seriesPanel, 'handles');
        eph = get(handles.ensemblePanel, 'handles');
        axes = {'obs', 'mean', 'noise', 'dwell'};
        thresholds = [1e-3, 0.1, 0.05 0.01];
        for ax = 1:length(axes)
            [x_lim, y_lim] = ...
                ebfret.plot.getlim(plots.posterior.(axes{ax}), ...
                    thresholds(ax), [0.05, 0.1, 0.05, 0.5]);
            if strcmp(axes{ax}, 'dwell')
                y_lim = [1e-2 * y_lim(2), 10 * y_lim(2)];
            end
            set(sph.axes.(axes{ax}), ...
                'XLim', x_lim, ...
                'YLim', y_lim, ...
                'YTick', linspace(y_lim(1), y_lim(2), 5));
            set(eph.axes.(axes{ax}), ...
                'XLim', x_lim, ...
                'YLim', y_lim, ...
                'YTick', linspace(y_lim(1), y_lim(2), 5));
            if strcmp(axes{ax}, 'obs')
                set(sph.axes.time, 'YLim', x_lim);
            end
        end
        % set logarithmic axis for dwell time plots
        set(sph.axes.dwell, 'XScale', 'log', 'YScale', 'log');
        set(eph.axes.dwell, 'XScale', 'log', 'YScale', 'log');
        % create prior plots
        u_m = analysis(a).prior.mu;
        u_beta = analysis(a).prior.beta;
        u_a = 0.5 .* analysis(a).prior.nu;
        u_b = 0.5 ./ analysis(a).prior.W;
        u_alpha = analysis(a).prior.A;
        plots.prior.mean = ...
            ebfret.plot.state_mean(u_m, u_beta, u_a, u_b, ...
                'xdata', {plots.posterior.mean.xdata}, ...
                'linestyle', '--', ...
                'color', plots.colors.state);
        plots.prior.noise = ...
            ebfret.plot.state_stdev(u_a, u_b, ...
                'xdata', {plots.posterior.noise.xdata}, ...
                'linestyle', '--', ...
                'color', plots.colors.state);
        plots.prior.dwell = ...
            ebfret.plot.state_dwell(u_alpha, ...
                'xdata', {plots.posterior.dwell.xdata}, ...
                'linestyle', '--', ...
                'color', plots.colors.state);
        % store prior and posterior plots
        set(self, 'plots', plots);

        % update ensemble plots
        handles = get(self, 'handles');
        fields = {'obs', 'mean', 'noise', 'dwell'};
        for f = 1:length(fields)
            mean_post = plots.posterior.(fields{f});
            for p = 1:length(plots.posterior.(fields{f}))
                mean_post(p).ydata = mean(mean_post(p).ydata, 2);
            end
            if strcmpi(fields{f}, 'obs')
                set_plots(handles.ensemblePanel, ...
                    fields{f}, mean_post);
            else
                set_plots(handles.ensemblePanel, ...
                    fields{f}, ...
                    ebfret.plot.cat(1, mean_post(:), ...
                        plots.prior.(fields{f})(:)));
            end
        end
        set_value(handles.ensembleControl, a);

        % update time series plots
        refresh_series(self, status.cur_series);
    else
        clear_plots(handles.ensemblePanel, ...
            {'obs', 'mean', 'noise', 'dwell'});
    end
end